# Fast & Slow Algorithm

- 토끼와 거북이 알고리즘
- 주어진 연결리스트에 사이클이 있는지 확인하는 알고리즘

### 알고리즘 개념

- [참고](https://fierycoding.tistory.com/45)
  - 증명하는 수식이 있다. 이해는 일단 패스
- `turtle`, `hare` 두 개의 포인터를 사용한다.
  - 둘 다 head 에서 출발하되, 각 순회에서 거북이는 한 칸, 토끼는 두 칸 이동한다.
- 사이클 유뮤: 토끼와 거북이가 만난다면, 사이클이 있는 것이다.
  - 토끼가 null 에 도달하면 사이클이 없는 것이다.
- 사이클 시작 지점 찾기
  - 토끼와 거북이가 만났을 때, 거북이를 시작점으로 보낸다.
  - 이 때무터는 토끼와 거북이 둘 다 한 칸씩 이동한다.
  - 토끼와 거북이가 다시 만나는 지점이 사이클의 시작점이다.

### Leetcode 141: Linked List Cycle

1. fast & slow + recursive
   - 재귀 대신 `while` 반복문이 더 빠르지만, 재귀 연습을 위해 재귀로 풀었다.
   - base case 를 정의한다.
     - false: 노드가 0개 또는 1개일 때
     - true: hare === turtle 일 때
   - 재귀의 인풋값 변화를 정의한다.
     - 거북이는 한 칸, 토끼는 두 칸 전진한다.
   - base case의 값을 바탕으로, 바로 윗 스택에서 답을 구할 수 있는 로직을 찾는다.
     - base case의 리턴값이 true || false 이므로, 이 값을 그대로 리턴하면 된다.
     - 단, base case 조건 확인 이후에 인풋값이 변화할 경우 true 조건으로 인한 무한루프가 발생하는 점을 유의한다. (최초에 hare, turtle 모두 head로 초기화)
2. brute force + hash table
   - 리스트를 traverse 하면서, 만나는 노드를 테이블(`new Set()`)에 저장한다.
   - 이 때 각 노드애 대해, 값 여부와 테이블에 이미 있는지 여부를 확인한다.
